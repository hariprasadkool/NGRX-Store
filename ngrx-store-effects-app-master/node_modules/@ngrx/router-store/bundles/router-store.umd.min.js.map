{"version":3,"sources":["../../../modules/router-store/src/router_store_module.ts","../../../modules/router-store/src/serializer.ts"],"names":["routerReducer","state","action","type","ROUTER_NAVIGATION","ROUTER_ERROR","ROUTER_CANCEL","payload","routerState","navigationId","event","id","_createDefaultRouterConfig","config","_config","Object","assign","stateKey","DEFAULT_ROUTER_FEATURENAME","RouterStateSerializer","prototype","serialize","DefaultRouterStateSerializer","_ROUTER_CONFIG","InjectionToken","ROUTER_CONFIG","StoreRouterConnectingModule","store","router","serializer","this","dispatchTriggeredByRouter","navigationTriggeredByDispatch","setUpBeforePreactivationHook","setUpStoreStateListener","setUpStateRollbackEvents","forRoot","ngModule","providers","provide","useValue","useFactory","deps","_this","hooks","beforePreactivation","shouldDispatchRouterNavigation","dispatchRouterNavigation","of","subscribe","s","storeState","select","navigateIfNeeded","url","navigateByUrl","events","e","RoutesRecognized","lastRoutesRecognized","NavigationCancel","dispatchRouterCancel","NavigationError","dispatchRouterError","dispatchRouterAction","urlAfterRedirects","dispatch","decorators","NgModule","args","useClass","ctorParameters","Store","Router","undefined","Inject"],"mappings":"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","file":"./dist/router-store/bundles/router-store.umd.min.js","sourcesContent":["import {\n  NgModule,\n  ModuleWithProviders,\n  InjectionToken,\n  Inject,\n} from '@angular/core';\nimport {\n  NavigationCancel,\n  NavigationError,\n  Router,\n  RouterStateSnapshot,\n  RoutesRecognized,\n} from '@angular/router';\nimport { Store } from '@ngrx/store';\nimport { of } from 'rxjs/observable/of';\nimport {\n  DefaultRouterStateSerializer,\n  RouterStateSerializer,\n} from './serializer';\n/**\n * An action dispatched when the router navigates.\n */\nexport const ROUTER_NAVIGATION = 'ROUTER_NAVIGATION';\n\n/**\n * Payload of ROUTER_NAVIGATION.\n */\nexport type RouterNavigationPayload<T> = {\n  routerState: T;\n  event: RoutesRecognized;\n};\n\n/**\n * An action dispatched when the router navigates.\n */\nexport type RouterNavigationAction<T = RouterStateSnapshot> = {\n  type: typeof ROUTER_NAVIGATION;\n  payload: RouterNavigationPayload<T>;\n};\n/**\n * An action dispatched when the router cancels navigation.\n */\nexport const ROUTER_CANCEL = 'ROUTER_CANCEL';\n\n/**\n * Payload of ROUTER_CANCEL.\n */\nexport type RouterCancelPayload<T, V> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationCancel;\n};\n\n/**\n * An action dispatched when the router cancel navigation.\n */\nexport type RouterCancelAction<T, V = RouterStateSnapshot> = {\n  type: typeof ROUTER_CANCEL;\n  payload: RouterCancelPayload<T, V>;\n};\n/**\n * An action dispatched when the router errors.\n */\nexport const ROUTER_ERROR = 'ROUTE_ERROR';\n\n/**\n * Payload of ROUTER_ERROR.\n */\nexport type RouterErrorPayload<T, V> = {\n  routerState: V;\n  storeState: T;\n  event: NavigationError;\n};\n\n/**\n * An action dispatched when the router errors.\n */\nexport type RouterErrorAction<T, V = RouterStateSnapshot> = {\n  type: typeof ROUTER_ERROR;\n  payload: RouterErrorPayload<T, V>;\n};\n\n/**\n * An union type of router actions.\n */\nexport type RouterAction<T, V = RouterStateSnapshot> =\n  | RouterNavigationAction<T>\n  | RouterCancelAction<T, V>\n  | RouterErrorAction<T, V>;\n\nexport type RouterReducerState<T = RouterStateSnapshot> = {\n  state: T;\n  navigationId: number;\n};\n/**\n * @template T\n * @param {?} state\n * @param {?} action\n * @return {?}\n */\nexport function routerReducer<T = RouterStateSnapshot>(\n  state: RouterReducerState<T>,\n  action: RouterAction<any>\n): RouterReducerState<T> {\n  switch (action.type) {\n    case ROUTER_NAVIGATION:\n    case ROUTER_ERROR:\n    case ROUTER_CANCEL:\n      return {\n        state: action.payload.routerState,\n        navigationId: action.payload.event.id,\n      };\n    default:\n      return state;\n  }\n}\n\nexport type StoreRouterConfig = {\n  stateKey?: string;\n};\n\nexport const /** @type {?} */ _ROUTER_CONFIG = new InjectionToken(\n  '@ngrx/router-store Internal Configuration'\n);\nexport const /** @type {?} */ ROUTER_CONFIG = new InjectionToken(\n  '@ngrx/router-store Configuration'\n);\nexport const /** @type {?} */ DEFAULT_ROUTER_FEATURENAME = 'routerReducer';\n/**\n * @param {?} config\n * @return {?}\n */\nexport function _createDefaultRouterConfig(config: any): StoreRouterConfig {\n  let /** @type {?} */ _config = {};\n\n  if (typeof config === 'function') {\n    _config = config();\n  }\n\n  return {\n    stateKey: DEFAULT_ROUTER_FEATURENAME,\n    ..._config,\n  };\n}\n\nexport type StoreRouterConfigFunction = () => StoreRouterConfig;\n/**\n * Connects RouterModule with StoreModule.\n * \n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n * \n * ```\n * export type RouterNavigationPayload = {\n *   routerState: RouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n * \n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n * \n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n * \n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n * \n * Usage:\n * \n * ```typescript\n * \\@NgModule({ \n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\nexport class StoreRouterConnectingModule {\n  static forRoot(\n    config?: StoreRouterConfig | StoreRouterConfigFunction\n  ): ModuleWithProviders;\n/**\n * @param {?=} config\n * @return {?}\n */\nstatic forRoot(\n    config: StoreRouterConfig | StoreRouterConfigFunction = {}\n  ): ModuleWithProviders {\n    return {\n      ngModule: StoreRouterConnectingModule,\n      providers: [\n        { provide: _ROUTER_CONFIG, useValue: config },\n        {\n          provide: ROUTER_CONFIG,\n          useFactory: _createDefaultRouterConfig,\n          deps: [_ROUTER_CONFIG],\n        },\n      ],\n    };\n  }\nprivate routerState: RouterStateSnapshot;\nprivate storeState: any;\nprivate lastRoutesRecognized: RoutesRecognized;\nprivate dispatchTriggeredByRouter: boolean = false;\nprivate navigationTriggeredByDispatch: boolean = false;\nprivate stateKey: string;\n/**\n * @param {?} store\n * @param {?} router\n * @param {?} serializer\n * @param {?} config\n */\nconstructor(\nprivate store: Store<any>,\nprivate router: Router,\nprivate serializer: RouterStateSerializer<RouterStateSnapshot>,\nprivate config: StoreRouterConfig\n  ) {\n    this.stateKey = this.config.stateKey as string;\n\n    this.setUpBeforePreactivationHook();\n    this.setUpStoreStateListener();\n    this.setUpStateRollbackEvents();\n  }\n/**\n * @return {?}\n */\nprivate setUpBeforePreactivationHook(): void {\n    ( /** @type {?} */((<any>this.router))).hooks.beforePreactivation = (\n      routerState: RouterStateSnapshot\n    ) => {\n      this.routerState = this.serializer.serialize(routerState);\n      if (this.shouldDispatchRouterNavigation())\n        this.dispatchRouterNavigation();\n      return of(true);\n    };\n  }\n/**\n * @return {?}\n */\nprivate setUpStoreStateListener(): void {\n    this.store.subscribe(s => {\n      this.storeState = s;\n    });\n    this.store.select(this.stateKey).subscribe(() => {\n      this.navigateIfNeeded();\n    });\n  }\n/**\n * @return {?}\n */\nprivate shouldDispatchRouterNavigation(): boolean {\n    if (!this.storeState[this.stateKey]) return true;\n    return !this.navigationTriggeredByDispatch;\n  }\n/**\n * @return {?}\n */\nprivate navigateIfNeeded(): void {\n    if (\n      !this.storeState[this.stateKey] ||\n      !this.storeState[this.stateKey].state\n    ) {\n      return;\n    }\n    if (this.dispatchTriggeredByRouter) return;\n\n    if (this.router.url !== this.storeState[this.stateKey].state.url) {\n      this.navigationTriggeredByDispatch = true;\n      this.router.navigateByUrl(this.storeState[this.stateKey].state.url);\n    }\n  }\n/**\n * @return {?}\n */\nprivate setUpStateRollbackEvents(): void {\n    this.router.events.subscribe(e => {\n      if (e instanceof RoutesRecognized) {\n        this.lastRoutesRecognized = e;\n      } else if (e instanceof NavigationCancel) {\n        this.dispatchRouterCancel(e);\n      } else if (e instanceof NavigationError) {\n        this.dispatchRouterError(e);\n      }\n    });\n  }\n/**\n * @return {?}\n */\nprivate dispatchRouterNavigation(): void {\n    this.dispatchRouterAction(ROUTER_NAVIGATION, {\n      routerState: this.routerState,\n      event: new RoutesRecognized(\n        this.lastRoutesRecognized.id,\n        this.lastRoutesRecognized.url,\n        this.lastRoutesRecognized.urlAfterRedirects,\n        this.routerState\n      ),\n    });\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nprivate dispatchRouterCancel(event: NavigationCancel): void {\n    this.dispatchRouterAction(ROUTER_CANCEL, {\n      routerState: this.routerState,\n      storeState: this.storeState,\n      event,\n    });\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nprivate dispatchRouterError(event: NavigationError): void {\n    this.dispatchRouterAction(ROUTER_ERROR, {\n      routerState: this.routerState,\n      storeState: this.storeState,\n      event: new NavigationError(event.id, event.url, `${event}`),\n    });\n  }\n/**\n * @param {?} type\n * @param {?} payload\n * @return {?}\n */\nprivate dispatchRouterAction(type: string, payload: any): void {\n    this.dispatchTriggeredByRouter = true;\n    try {\n      this.store.dispatch({ type, payload });\n    } finally {\n      this.dispatchTriggeredByRouter = false;\n      this.navigationTriggeredByDispatch = false;\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  providers: [\n    { provide: RouterStateSerializer, useClass: DefaultRouterStateSerializer },\n    {\n      provide: _ROUTER_CONFIG,\n      useValue: { stateKey: DEFAULT_ROUTER_FEATURENAME },\n    },\n    {\n      provide: ROUTER_CONFIG,\n      useFactory: _createDefaultRouterConfig,\n      deps: [_ROUTER_CONFIG],\n    },\n  ],\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Store, },\n{type: Router, },\n{type: RouterStateSerializer, },\n{type: undefined, decorators: [{ type: Inject, args: [ROUTER_CONFIG, ] }, ]},\n];\n}\n\nfunction StoreRouterConnectingModule_tsickle_Closure_declarations() {\n/** @type {?} */\nStoreRouterConnectingModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStoreRouterConnectingModule.ctorParameters;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.routerState;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.storeState;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.lastRoutesRecognized;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.dispatchTriggeredByRouter;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.navigationTriggeredByDispatch;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.stateKey;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.store;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.router;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.serializer;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.config;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { InjectionToken } from '@angular/core';\nimport { RouterStateSnapshot } from '@angular/router';\n/**\n * @abstract\n */\nexport abstract class RouterStateSerializer<T> {\n/**\n * @abstract\n * @param {?} routerState\n * @return {?}\n */\nserialize(routerState: RouterStateSnapshot) {}\n}\nexport class DefaultRouterStateSerializer\n  implements RouterStateSerializer<RouterStateSnapshot> {\n/**\n * @param {?} routerState\n * @return {?}\n */\nserialize(routerState: RouterStateSnapshot) {\n    return routerState;\n  }\n}\n"]}